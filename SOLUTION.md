## Project: 3D Motion Planning
![Quad Image](./misc/enroute.png)

---


# Required Steps for a Passing Submission:
1. Load the 2.5D map in the colliders.csv file describing the environment.
2. Discretize the environment into a grid or graph representation.
3. Define the start and goal locations.
4. Perform a search using A* or other search algorithm.
5. Use a collinearity test or ray tracing method (like Bresenham) to remove unnecessary waypoints.
6. Return waypoints in local ECEF coordinates (format for `self.all_waypoints` is [N, E, altitude, heading], where the droneâ€™s start location corresponds to [0, 0, 0, 0].
7. Write it up.
8. Congratulations!  Your Done!

## [Rubric](https://review.udacity.com/#!/rubrics/1534/view) Points
### Here I will consider the rubric points individually and describe how I addressed each point in my implementation.  

---
### Writeup / README

#### 1. Provide a Writeup / README that includes all the rubric points and how you addressed each one.  You can submit your writeup as markdown or pdf.  

You're reading it! Below I describe how I addressed each rubric point and where in my code each point is handled.

### Explain the Starter Code

#### 1. Explain the functionality of what's provided in `motion_planning.py` and `planning_utils.py`
These scripts contain a basic planning implementation that includes...

**RESPONSE :**

Drone starts in `MANUAL` state at the time of initialization. Initialization also registers callbacks for `LOCAL_POSITION`, `LOCAL_VELOCITY` and `STATE` messages generated by Drone Auto Pilot.
1. `STATE` msg transitions the drone from `MANUAL` to `ARMING` in `arming_transition()` function. The function also arms the drone and sets it mode to guided so that program can control the drone.
2. `STATE` msg then transitions the dron from `ARMING` to `PLANNING` by calling `plan_path()` from `state_callback()`
3. `plan_path()` plans the path based on start and end goals. It generates the `waypoints` and sets this into class memeber `self.waypoints`.
4. Next `STATE` msg sets the drone state to `TAKEOFF` by calling `self.takeoff_transition()` from `state_callback()`. It also takes the drone to `target_position` altitude by calling Drone class's `takeoff(target_altitude)` function.
5. `LOCAL_POSTION` msg callbacks `local_position_callback` which in turn drone has achieved the desired altitude. Once drone reaches the target position altitude, this callback transitions the drone to `WAYPOINT` state by calling `waypoint_transition`. Inside `waypoint_transition`, first waypoint from `self.waypoints` is poped and fed into drone as the next location to go using Drone class's `cmd_position()` function.
6. `LOCAL_POSTION` msg call keep `local_position_callback` and now in `WAYPOINT` state, this callback monitors if drone has reached its immediate target. Once drone reaches the immediate target, `local_position_callback` again calls `waypoint_transition()` function to feed the next waypoint as the new immeidate target for the drone. In case there are no more waypoints left to follow in the list `self.waypoints`, the callback transitions the drone to `LANDING` state by calling `landing_transition()`. `landing_transition()`, apart from changing the state to `LANDING` also issues the land command to drone by calling Drone class's `self.land()` function.
7. `LOCAL_VELOCITY` msg calls `velocity_callback()` which checks if the drone has reached its final landing destination including altitude to be close to zero (i.e. ground). Once that happens, the callback transitions drone to `DISARMING` state by calling `disarming_transition()` which in turn disarms and  release control of the drone.
8. In `DISARMING` state of drone, the next `STATE` msg sets the drone back to original state i.e. `MANUAL` state and also flags that drone is in no more `mission` mode.

So the state transitions are:
MANUAL -> ARMING -> PLANNING -> TAKEOFF -> WAYPOINT -> LANDING -> DISARMING -> MANUAL

All the path planning is done in `plan_path()` function. In the starter code, the obstacles are loaded from `colliders.csv`. A 2-d grid for a given altitude is created by calling `create_grid()` function inside `planning_utils.py`. The function then defines start point as center of grid and goal as some random point in the grid.

A path is then planned from `start` to `goal` in a world where only four actions `UP`, `DOWN`, `LEFT`, `RIGHT` can be performed. This creates a jagged waypoints between start and goal. A* is used for path planning.

### Implementing Your Path Planning Algorithm

#### 1. Set your global home position
Here students should read the first line of the csv file, extract lat0 and lon0 as floating point values and use the self.set_home_position() method to set global home. Explain briefly how you accomplished this in your code.

**RESPONSE :**

I used `readline` function from python's builtin IO package to read the first line of `colliders.csv`. then comma `,` is replaced by space. The line is then split using python string function `split` and then converted into a numpy array. 1st and 3rd elements are extracted which contain the latitude and longitude. The datatype is then changed to `np.float64` and the array is unpacked into `lat0` and `long0`

```python
with open('colliders.csv') as f:
    line = np.array(f.readline().replace(',', ' ').split())
    line = line[[1,3]]
    lat0, lon0 = np.asarray(line, dtype=np.float64)
```

#### 2. Set your current local position
Here as long as you successfully determine your local position relative to global home you'll be all set. Explain briefly how you accomplished this in your code.

**RESPONSE:**

We first get the the current global position and then convert it into current_local using `global_to_local`

```python
# TODO: retrieve current global position
current_global = self.global_position

# TODO: convert to current local position using global_to_local()
current_local = global_to_local(current_global, self.global_home)
```

#### 3. Set grid start position from local position
This is another step in adding flexibility to the start location. As long as it works you're good to go!

**RESPONSE:**

```python
grid_start = (int(current_local[0])-north_offset, int(current_local[1])-east_offset)
```

#### 4. Set grid goal position from geodetic coords
This step is to add flexibility to the desired goal location. Should be able to choose any (lat, lon) within the map and have it rendered to a goal location on the grid.

**RESPONSE:**

```python
lat_goal = 37.794766  #value user chooses
lon_goal = -122.399456 #value user chooses
goal_global = [lon_goal, lat_goal, 0.] # convert to global coords [long, lat, altitude]
goal_local = global_to_local(goal_global, self.global_home) # conver to local
grid_goal = (int(goal_local[0])-north_offset, int(goal_local[1])-east_offset) #set grid goal
```

#### 5. Modify A* to include diagonal motion (or replace A* altogether)
Minimal requirement here is to modify the code in planning_utils() to update the A* implementation to include diagonal motions on the grid that have a cost of sqrt(2), but more creative solutions are welcome. Explain the code you used to accomplish this step.

**RESPONSE:**

A-star was modified in two places to account for diagonal moves.

First, 4 more diagonal actions were appended with cost of sqrt(2) in `class Action(Enum)`
```python
NORTH_WEST = (-1, -1, np.sqrt(2))
NORTH_EAST = (-1, 1, np.sqrt(2))
SOUTH_WEST = (1, -1, np.sqrt(2))
SOUTH_EAST = (1, 1, np.sqrt(2))
```

Second, the `valid_actions()` method was modified to ensure that none of the diagonal moves lead to going off the grid or land the move into a blocked cell.

```python
if (x - 1 < 0 or y - 1 < 0) or grid[x - 1, y - 1] == 1:
    valid_actions.remove(Action.NORTH_WEST)
if (x - 1 < 0 or y + 1 > m) or grid[x - 1, y + 1] == 1:
    valid_actions.remove(Action.NORTH_EAST)
if (x + 1 > n or y - 1 < 0) or grid[x + 1, y - 1] == 1:
    valid_actions.remove(Action.SOUTH_WEST)
if (x + 1 > n or y + 1 > m) or grid[x + 1, y + 1] == 1:
    valid_actions.remove(Action.SOUTH_EAST)
```

#### 6. Cull waypoints
For this step you can use a collinearity test or ray tracing method like Bresenham. The idea is simply to prune your path of unnecessary waypoints. Explain the code you used to accomplish this step.

**RESPONSE:**

I used both the methods, first collinearity and then Bresenham.

*collinearity* - this pruning was implemented following the code examples shown in lesson exercises. We take three consecutive points and eliminate the middle one if all three consecutive points are collinear. As we are dealing with integer coordinates, we use faster integer based implementation for collinearity check.

```python
def collinearity_int(p1, p2, p3):
    collinear = False
    collinear = p1[0]*(p2[1] - p3[1])+p2[0]*(p3[1] - p1[1])+p3[0]*(p1[1] - p2[1]) == 0

def prune_path(path):
    pruned_path = [p for p in path]

    i = 0
    while i < len(pruned_path) - 2:
        if collinearity_int(pruned_path[i], pruned_path[i+1], pruned_path[i+2]):
            pruned_path.remove(pruned_path[i+1])
        else:
            i += 1
    return pruned_path
```

As this reduced only few points still leaving the path to be jagged, I then implemented Bresenham path pruning. The code with explanation is given below:

```python
def bresenham_feasible(grid, p1, p2):
    # first get all the x and y coordinates of cells that are covered
    # from p1 to p2 using bresenham algorithm
    cells = np.transpose(list(bresenham(p1[0], p1[1], p2[0], p2[1])))
    # now use 'index arrays' indexing of numpy to get a flat array
    # consisting of only the bresenham cells from grid
    # and if all these cells contain zero (i.e. np.sum == 0),
    # then p1 to p2 can be connected without hitting any obstacle
    return np.sum(grid[cells[0], cells[1]]) == 0

def bresenham_prune(grid, path):
    pruned_path = []

    #append start point to pruned path
    i = 0
    pruned_path.append(path[i])
    # index i is the start point p1 for `bresenham_feasible`
    while i < len(path) - 1:
        p1 = path[i]
        # iterate from j=i+1 to end till bresenham_feasible Returns
        # false indicating that i and j-1 can be joined but not i and j
        for j in range(i+1, len(path)):
            p2 = path[j]
            if not bresenham_feasible(grid, p1, p2):
                # append j-1 as the next waypoint
                # and then start all over from i=j-1 to end
                pruned_path.append(path[j-1])
                i = j-1
                break
        i += 1
    # append the last waypoint from input path to pruned_path
    pruned_path.append(path[-1])
    return pruned_path
```

### Execute the flight
#### 1. Does it work?
It works!

### Double check that you've met specifications for each of the [rubric](https://review.udacity.com/#!/rubrics/1534/view) points.

# Extra Challenges: Real World Planning

For an extra challenge, consider implementing some of the techniques described in the "Real World Planning" lesson. You could try implementing a vehicle model to take dynamic constraints into account, or implement a replanning method to invoke if you get off course or encounter unexpected obstacles.
